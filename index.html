<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>一般圖最大權匹配</title>
		<meta name="description" content="General Graph Weighted Match Algorithm">
		<meta name="author" content="SunMoon Master">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/style.css"><!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
		<!-- Printing and PDF exports --><script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script><!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
	</head>
	<body>
	<div></div>
	<div class="reveal">
		<div class="slides">
			\( 
			  \newcommand{\ord}[1]{\mathcal{O}\left(#1\right)}
			  \newcommand{\abs}[1]{\lvert #1 \rvert}
			  \newcommand{\floor}[1]{\lfloor #1 \rfloor}
			  \newcommand{\ceil}[1]{\lceil #1 \rceil}
			  \newcommand{\opord}{\operatorname{\mathcal{O}}}
			  \newcommand{\argmax}{\operatorname{arg\,max}}
			  \newcommand{\str}[1]{\texttt{"#1"}}
			\)
			<!-- ... 這裡是註解文字 ... -->
			<section>
				<h1>一般圖最大權匹配</h1>
				<p><div class="small">general graph weighted match</div></p>
				<p><div class="small">南天門日月卦長</div></p>
			</section>
			<section>
				<section>
					<h1>甚麼是匹配?</h1>
				</section>
				<section>
					<h2>匹配</h2>
					一張圖\(G=(V,E)\)，這張圖的一個匹配\(M\)是圖\(G\)的一個子圖，其中每兩條邊都不相鄰（沒有公共頂點）<br/>
					且所有點的\(degree = 1\)<br/>
					<img src="img/Maximal-matching.svg">
				</section>
				<section>
					<h2>最大匹配</h2>
					<p>
						圖\(G\)的一個 <b>最大匹配</b> ，指邊數最多的匹配。
					</p>
					<b>最大匹配</b> 可能有不止一個，但 <b>最大匹配</b> 的邊數是確定的，並且不可能超過圖中頂點數的一半。<br/>
					<img src="img/Maximum-matching-labels.svg">
				</section>
				<section>
					<h2>完美匹配</h2>
					圖\(G\)的 <b>最大匹配</b> 包含所有原圖的所有點，稱為 <b>完美匹配</b><br/>
					若\(G\)為完全圖且頂點數為偶數時，必然存在 <b>完美匹配</b>
				</section>
			<section>
					<h2>最大權匹配</h2>
					<h5>maximum weight matching</h5>
					<p>
						一張圖\(G=(V,E)\)<br>
						\(\forall e \in E\)存在一個函數\(w(e)\)表示\(e\)的權重
					</p>
					圖\(G\)的一個 <b>最大權匹配</b> \(M=(V',E')\)是圖\(G\)的一個子圖<br/>
					滿足\( \sum w(e): e \in E'\)為其所有匹配中最大的<br/>
					<img src="img/example_weighted_graph.png">
				</section>
				<section>
					<h2>最大權最大匹配</h2>
					<h5>maximum weight maximum cardinality matching</h5>
					圖\(G\)的一個 <b>最大權最大匹配</b> \(M=(V',E')\)<br/>
					滿足\( \sum w(e): e \in E'\)為其所有 <b>"最大匹配"</b> 中最大的<br/>
					<img src="img/example_max_edge_weighted_graph.png">
				</section>
				<section>
					<h2>最大權完美匹配</h2>
					<h5>maximum weight maximum perfect matching</h5>
					若圖\(G\)存在完美匹配<br/>
					此時圖\(G\)的 <b>最大權最大匹配</b> 稱為 <b>最大權完美匹配</b>
				</section>
			</section>
			<section>
				<h1>匹配算法的轉換</h1>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						## 用
						## 最大權最大匹配
						## 求
						## 最大權匹配
					</script>
				</section>
				<section>
					<p>
						<b>最大權最大匹配</b> 允許負權邊\((w(e)<0)\)<br/>
						但是 <b>最大權匹配</b> 不會有負權邊
					</p>
					若一張圖\(G\)其所有的邊皆為負權<br/>
					則其 <b>最大權匹配</b> \(M=\varnothing\)
				</section>
				<section>
					<h2>調整邊的權重</h2>
					先將圖\(G\)的所有負權邊其權重\(w(e)\)設為\(0\)<br/>
					在進行接下來的步驟
				</section>
				
				<section>
					<h2>完全圖性質</h2>
					<p>在\(G\)為完全圖且沒有負權邊時</p>
					<b>最大權最大匹配</b> = <b>最大權匹配</b>
				</section>
				<section>
					所以把\(G\)補成完全圖，補上的邊其權重為\(0\)<br/>
					計算 <b>最大權最大匹配</b> 後再把權重為\(0\)的邊去除即可<br/>
					<img src="img/example_max_edge_weighted_graph-change.png">
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						## 用
						## 最大權匹配
						## 求
						## 最大權最大匹配
					</script>
				</section>
				<section>
					<b>最大權匹配</b> 不會有負權邊<br/>
					且零邊\( (w(e)=0) \)可選可不選<br/>
					但是 <b>最大權最大匹配</b> 允許負權邊和零邊
				</section>
				<section>
					<h2>調整邊的權重</h2>
					<p>令 \(K = max(\{\abs{w(e)}: e \in E ,\; w(e) ≤ 0 \}) + 1 \)</p>
					若沒有負權邊或零邊則\(K = 0\)
				</section>
				<section>
					<h2>調整邊的權重</h2>
					<p>把圖\(G\)中所有的邊其權重\(w(e)\)加上\(K\)產生一張新圖\(G'=(V,E')\)</p>
					此時的新圖\(G'\)不存在負權邊和零邊
				</section>
				<section>
					<h2>問題來了</h2>
					<p>
						<b>最大權最大匹配</b> 不一定等於 <b>最大權匹配</b><br/>
						但是把所有邊的邊權加上一個超大數字\(P\)的話<br/>
						<b>最大權匹配</b> 的結果就是 <b>最大權最大匹配</b>
					</p>
					但是\(P\)取要多大?
				</section>
				<section>
					<h2>調整邊的權重</h2>
					<p>令\(P = max(\{w(e): e \in E'\})\)</p>
					把圖\(G'\)中所有的邊其權重\(w(e)\)加上\(P\)<br/>
					產生一張新圖\(G''=(V,E'')\)
				</section>
				<section>
					此時對圖\(G''\)進行 <b>最大權匹配</b><br/>
					其結果可以對應原圖的 <b>最大權最大匹配</b><br/>
					<img src="img/example_max_weighted_graph-change.png">
				</section>
			</section>
			<section>
				<h1>最大匹配算法</h1>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 二分圖最大匹配
						## Bipartite Matching
					</script>
				</section>
				<section>
						<h2>flow</h2>
						最簡單的方法是用網路流，所以就不多講了<br/>
						Dinic在這種特殊圖上複雜度為\( \ord{|E|\sqrt{|V|}} \)<br/>
						<img src="img/flow-matching.png">
				</section>
				<section data-markdown>
					<script type="text/template">
						## 匈牙利算法
						這是這份投影片主要要講的
						
						在學習他之前必須要有一些預備知識
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 匈牙利算法-預備知識
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 定義
						
						**匹配點**
						
						**匹配邊**
						
						**未匹配點**
						
						**非匹配邊**
						
						它們的含義非常顯然
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						交替路(Alternating Path)：從一個未匹配點出發，依次經過非匹配邊、匹配邊、非匹配邊…形成的路徑叫交替路。

						增廣路(Agumenting Path)：從一個未匹配點出發，走交替路，如果途徑另一個未匹配點(出發的點不算)，則這條交替路稱為增廣路。
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/Bipartite.png)
						![Alt text](img/BipartiteAgumentingPath.png)
						
						原圖和增廣路
					</script>
				</section>
				<section>
					<h2>交錯樹</h2>
					<div class="theorem">
						<div class="label">交錯樹</div>
						alternating tree<hr/>
						在進行DFS或BFS尋找增廣路的過程產生的樹稱為交錯樹<br/>
						設 \(T=(V_t,E_t)\)為在尋找增廣路時產生的交錯樹<br/>
						定義:<br/>
						偶點為樹上深度為偶數的點<br/>
						奇點為樹上深度為奇數的點
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 二分圖的偶點奇點
						二分圖是很特別的圖<br/>
						可以把它的點分成兩個集合
						
						其中一個集合的點在交錯樹上永遠是奇點<br/>
						另一集合的點在交錯樹上永遠是偶點
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 原圖及交錯樹
						![Alt text](img/originalB.png)
						![Alt text](img/search tree.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						有沒有人發現把增廣路的匹配邊和非匹配邊反轉就可以增加匹配數量?
						
						匈牙利算法中只透過這樣的方式增加匹配數量
						
						稱為Augment(擴充)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						那如果有一個未匹配點，找不到以此點作為端點的增廣路(無法擴充)怎麼辦?
					</script>
				</section>
			</section>
			<section>
				<section>
					<h2>Berge's Theorem</h2>
					<div class="theorem">
						<div class="label">定理</div>
						Berge's Theorem<hr/>
						從圖上任取一個未匹配點，如果找不到以此點作為端點的增廣路，那麼這張圖會有一些最大匹配不會包含此點。
					</div>
					<div class="fragment">接下來我們要來證明Berge's Theorem</div>
				</section>
				<section>
					<h2>對稱差集</h2>
					<div class="theorem">
						<div class="label">定義</div>
						對稱差集<hr/>
						兩個集合 \(A\) 和 \(B\) 的「對稱差集」定義為<br/>
						\(A⊕B = (A∪B) - (A∩B)\)
					</div>
				</section>
				<section>
					<p>同一張圖上的兩種匹配\(M\)和\(M^*\)也可以計算對稱差集</p>
					\(M⊕M^*\)總共會產生六大類 connected component
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/connected_component.png)
					</script>
				</section>
				<section>
					設當下的匹配\(M\)找不到以未匹配點\(p\)作為端點的擴充路徑<br/>
					並令\(M^*\)是該圖的其中一個最大匹配。
				</section>
				<section>
					<h2>如果\(p\)不在\(M^*\)上</h2>
					<div class="theorem">
						<div class="label">證明</div>
						Berge's Theorem<hr/>
						刪除此點完全不會對\(M\)和\(M^*\)有任何影響，定理成立。
					</div>
				</section>
				<section>
					<h2>如果\(p\)在\(M^*\)上</h2>
					<div class="theorem">
						<div class="label">證明</div>
						Berge's Theorem<hr/>
						1. \(p\)對於M來說是未匹配點。理所當然\(p\)不在\(M\)上。<br/>
						2. 考慮\(M⊕M^*\)的六種情形。\(p\)不在\(M\)上，且\(p\)在\(M^*\)上，所以只有d或e符合條件。<br/>
						3. \(M\)找不到以\(p\)作為端點的擴充路徑，所以d不符合條件，只有e符合條件。<br/>
						4. 對於\(M^*\)來說，只要照著e顛倒匹配邊和未匹配邊，
						就可以製造出另一個不會包含p的最大匹配，
						成為1.的情形，定理還是成立。
					</div>
					<div class="fragment">結論:Berge's Theorem是正確的</div>					
				</section>
			</section>
			<section>
				<section>
					<h1>匈牙利算法</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						有了Berge's Theorem<br/>
						我們可以用以下的方法找最大匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						一開始圖上所有點都是未匹配點<br/>
						將圖上每一個未匹配點都嘗試作為增廣路的端點
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如果找得到增廣路:
						沿著增廣路修改現有匹配(擴充)<br/>
						此未匹配點變成了匹配點
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如果找不到擴充路徑
						直接刪除此點<br/>
						繼續下去仍然可以找到原圖的其中一個最大匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接下來來看code
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						用vector存圖<br/>
						若G[x]=y，則x和y之間有一條邊<br/>
						match為匹配結果，若match[y]=x<br/>
						則x和y之間有一條匹配邊
						
						注意:因為是二分圖，可以把點分成兩個集合<br/>
						x和y在不同的集合，所以編號可以一樣
						``` cpp
						#define MAXN 1000
						vector<int> G[MAXN];
						int match[MAXN];
						int n;//n個點，編號為0 ~ n-1
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						bool vis[MAXN];
						bool dfs(int x){
							for(size_t i=0;i<G[x].size();++i){
								int y=g[x][i];
								if(vis[y])continue;
								vis[y]=true;
								if(match[y]==-1||dfs(match[y])){
									match[y]=x;
									return true;
								}
							}
							return false;
						}
						```
						如果有增廣路就進行擴充並return true<br/>
						否則return false
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最後是主函數
						``` cpp
						inline int max_match(){
							int ans=0;
							memset(match,-1,sizeof(int)*n);
							for(int x=0;x<n;++x){
								memset(vis,0,sizeof(bool)*n);
								if(dfs(x))++ans;
							}
							return ans;
						}
						```
						ans為最大匹配數量
					</script>
				</section>
				<section>
					<h2>複雜度</h2>
					總共做了\(|V|\)次dfs<br/>
					每次dfs花了\( \ord{|V|+|E|} \)的時間<br/>
					總複雜度為\( \ord{|V|*(|V|+|E|)} \)
				</section>
				<section data-markdown>
					<script type="text/template">
						## 複雜度
						好像比網路流慢?
						
						這個方法好寫，而且可以求字典序最小的最大匹配
					</script>
				</section>
			</section>
			<section data-markdown>
				<script type="text/template">
					# 一般圖最大匹配
					## General Graph Matching
				</script>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 帶花樹算法
						## Blossom algorithm
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 花的概念
						一般圖跟二分圖最大的差別就是奇環<br/>
						在交替路上行走的時候，如果遇到奇環<br/>
						那就把奇環縮成一朵花(blossom)<br/>
						並把花中所有點設成偶點
						
						既然花上的點都可以成為偶點<br/>
						那麼乾脆把花直接縮成一個偶點<br/>
						會讓交錯樹變得更簡潔明白
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/750px-Edmonds_blossom.svg.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						縮花之後把整個花當成一個點<br/>
						值得注意的是，花裡可以包含其它花
						
						繼續尋找增廣路，如果有找到增廣路<br/>
						和匈牙利算法一樣，必須擴充路徑<br/>
						這個時候要處理花的問題<br/>
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/750px-Edmonds_lifting_path.svg.png)
					</script>
				</section>
				<section>
					<p>這樣基本問題就解決了，來計算一下時間複雜度</p>
					<p>
						因為一朵花最少有三個點，縮花後成為一個點<br/>
						由此推得：N個點的圖建立一棵交錯樹，最多縮花N/2次
					</p>
					所以找出增廣路的時間複雜度為:<br/>
					\( \ord{|E|+|V|} + \ord{|E|+|V|}  = \ord{|E|+|V|} \)<br/>
					BFS的時間加上縮花總時間
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接著就用匈牙利算法來求最大匹配
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 實作細節
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## BFS
						首先是BFS，如果不用BFS的話
						
						奇點變偶點的操作會很難處理
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如何記錄花
						1. disjoint set
						  * 想法簡單
						  * code略長
						2. 只記錄有可能增廣的邊
						  * 效率高
						  * 好實作
						
						##這裡使用方法2
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						一朵花裡可能會有其他的花<br/>
						那花裡也可能會包含其他花<br/>
						層層疊疊
						
						但是增廣的時候只會有一條路徑被增廣
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						因為花是在BFS時建構出來的<br/>
						BFS之後要把花拆掉<br/>
						
						所以一朵花只會有一個奇環<br/>
						其環上的某條鏈有機會被增廣<br/>
						
						因此只需要紀錄哪些點在這個環上即可
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						圖中節點的編號為BFS順序<br/>
						白色的部分表示還沒遍歷<br/>
						灰色表示一般節點<br/>
						相同顏色表示在相同的花裡面<br/>
						
						可以看出 3 和 9 在黃色的花和藍色的花形成時被遺棄了
						
						![Alt text](img/blossom.gif)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						不需要擔心被遺棄的節點<br/>
						之後不會再經過且不可能被增廣
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 來看看code
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						#define MAXN 505
						vector<int>g[MAXN];//用vector存圖 
						int pa[MAXN],match[MAXN],st[MAXN],S[MAXN],vis[MAXN];
						//pa表示交錯樹每個節點的父母節點
						//match[u]=v表示u和v匹配，同時match[v]=u
						//st[u]=B表示節點u屬於B這朵花
						//S[u]={-1:沒走過 0:偶點 1:奇點}
						//vis只用在找lca的時候檢查是不是走過了
						int n;//n個點，編號為1 ~ n
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline int lca(int u,int v){
							//找花的花托，也就是交錯樹的lca
							//這種方法可以不用清空vis陣列就可以判斷有沒有經過
							static int t=0;
							for(++t;;swap(u,v)){
								if(u==0)continue;
								if(vis[u]==t)return u;
								vis[u]=t;
								u=st[pa[match[u]]];
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						#define qpush(u) q.push(u),S[u]=0
						//因為丟進queue裡的節點必為偶點，故把兩個操作寫在一起
						
						inline void flower(int u,int v,int l,queue<int> &q){
							//這個函數用來設定花裡面所有點的pa
							while(st[u]!=l){
								pa[u]=v;//所有未匹配邊的pa都是雙向的 
								v=match[u];
								if(S[v]==1)qpush(v);//所有奇點變偶點 
								st[u]=st[v]=l;
								//注意這邊以花的花托代表這個花
								//所以 st[u]=st[v]=l 就是設定 u 和 v 屬於 l 這朵花
								u=pa[v];
							}
						}
						```
						執行
						``` cpp
						flower(v,u,lca,q);
						flower(u,v,lca,q);
						```
						就可以設定花裡面所有點的pa
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						執行
						``` cpp
						flower(v,u,lca,q);
						flower(u,v,lca,q);
						```
						的結果
						
						![Alt text](img/pa_set.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool agument(int u,int v){
							//擴充增廣路
							for(int lst;u;v=lst,u=pa[v]){
								lst=match[u];
								match[u]=v;
								match[v]=u;
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool bfs(int u){
							for(int i=1;i<=n;++i)st[i]=i;//自己一個點也是奇環
							memset(S+1,-1,sizeof(int)*n);
							queue<int>q;
							qpush(u);
							while(q.size()){
								u=q.front(),q.pop();
								for(size_t i=0;i<g[u].size();++i){
									int v=g[u][i];
									if(S[v]==-1){
										pa[v]=u;
										S[v]=1;
										if(!match[v]){//有增廣路直接擴充 
											agument(u,v);
											return true;
										}
										qpush(match[v]);
									}else if(!S[v]&&st[v]!=st[u]){
										int l=lca(v,u);//遇到花，做花的處理 
										flower(v,u,l,q);
										flower(u,v,l,q);
									}
								}
							}
							return false;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最後是主函數
						``` cpp
						inline int blossom(){
							//ans表示最大匹配數量
							memset(pa+1,0,sizeof(int)*n);
							memset(match+1,0,sizeof(int)*n);
							int ans=0;
							for(int i=1;i<=n;++i)
								if(!match[i]&&bfs(i))++ans;
							return ans;
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度分析</h2>
					<p>
						之前有討論過bfs加上縮花的時間為\(\ord{|E|+|V|}\)<br/>
						總共會進行\(|V|\)次bfs
					</p>
					故總複雜度為\( \ord{|V|*(|E|+|V|)} \)
				</section>
			</section>
			<section data-markdown>
				<script type="text/template">
					# 最大權匹配算法
				</script>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 二分圖最大權匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						# 預備知識
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 線性規劃的對偶(duality)
						一個線性規劃問題可以從兩個不同的角度來分析<br/>
						其一，評估每一產品的獲利情況，而使總利潤極大化<br/>
						另一為評估生產產品所付出的成本，而使總成本極小化<br/>
						實為一物的兩面，從不同的角度觀察同一問題
					</script>
				</section>
				<section>
					<h2>定義函數</h2>
					設\(S ⊆ V\)<br/>
					\(δ(S) = \{ (u, v) ∈ E \; : \; u ∈ S, \; v ∈ V − S \} \)<br/>
					對單一點 \(v ∈ V \) ，我們定義 \(δ(v) = δ(\{v\}) \)<br/>
				</section>
				<section>
					<h2>二分圖最大權完美匹配的線性規劃</h2>
					<div class="prob">
						<div class="label">原始問題</div>
						PRIMAL<hr/>
						<p>\( max \; \sum_{e∈E} \; w(e)x_e \)</p>
						<p>
							限制:<br/>
							\(x_e ≥ 0 \; : \forall e∈E \)<br/>
							\( x(δ(u)) = 1 \; : \forall u∈V \)
						</p>
						定義:<br/>
						\(x(S) = \sum_{e∈S} \; x_e\)
					</div>
					<div class="fragment">接下來進行對偶問題的轉換</div>					
				</section>
				<section>
					<h2>二分圖最大權完美匹配的對偶問題</h2>
					<div class="prob">
						<div class="label">對偶問題</div>
						DUAL<hr/>
						<p>\( min \; \sum_{u \in V} \; z_u \)</p>
						<p>
							限制:<br/>
							\(z_e ≥ 0 \; : \forall e∈E \)
						</p>
						設 \(e=(u,v)\)，這裡\(z_e = z_u + z_v - w(e)\)
					</div>
					<div class="fragment">所有條件都滿足時\(\sum_{u∈V} \; z_u\)就是最大權匹配的權重和</div>
					<div class="fragment">原本求最大值問題就變成求最小值了!</div>
				</section>
				<section>
					<h2>二分圖最大權完美匹配的對偶問題</h2>
					<p>
						在原始問題中，我們發現只要在\(x_e \in \{0,1\} \; : \forall e \in E \)時<br/>
						\(x_e = 1\)的邊就是匹配邊，\(x_e = 0\)的邊就是非匹配邊
					</p>
					不過線性方程的解中，\(x_e\)不一定是整數<br/>
					但是一定存在\(x_e \in \{0,1\}\)的整數解<br/>
					所以想辦法讓他產成整數解即可
				</section>
				<section>
					<h2>二分圖最大權完美匹配的對偶問題</h2>
					<p>
						我們稱\(z_u\)為u的vertex labeling<br/>
						稱\(z_e=0\)的邊為等邊(Equality Edge)
					</p>
					只要在最大權完美匹配的時候<br/>
					讓所有匹配邊都是等邊<br/>
					這樣就可以滿足\(x_e \in \{0,1\}\)的條件了
				</section>
				<section>
					<h2>寫成數學符號長這樣</h2>
					<div class="theorem">
						\(x_e>0 \; \longrightarrow \; z_e=0 \qquad \forall e \in E\)
					</div>
				</section>
				<section>
					<p>
						以「等邊」的概念，結合之前的匈牙利算法:
					</p>
					<p>
						用「等邊」構成的增廣路不斷進行擴充<br/>
						由於用來擴充的邊全是「等邊」<br/>
						最後得到的最大權完美匹配當然全是「等邊」
					</p>
					<div class="fragment">找不到「等邊」?只好調整vertex labeling了</div>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					vertex labeling 仍要維持大於等於的性質<br/>
					而且既有的「等邊」不能被改變。
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr/>
						<p>
							設交錯樹 \( T = (U_t,V_t) \)<br/>
							令 \( d = min(\{z_e : e \in δ(V_t)\})\)<br/>
							設\(u^+\)為樹上偶點，\(v^-\)為樹上奇點<br/>
							讓 \(z_{u^+}\)-= \(d, \;\)\(z_{v^-}\) += \(d\)
						</p>

						如此便製造了一條(以上)的等邊，且既有等邊保持不動<br/>
						並維持了\(z_e ≥ 0 \; : \forall e∈E \)的性質<br/>
						接著就繼續找增廣路!
					</div>
				</section>
				<section>
					因為是二分圖<br/>
					所以可以事先知道哪些點是奇點<br/>
					哪些點是偶點
					<div class="theorem">
						我們一開始的時候可以設定:<br/>
						所有\(u\)為偶點，\(z_u=max(\{w(e): e \in E\})\)<br/>
						所有\(v\)為奇點，\(z_v=0\)
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 還是會有問題
						這樣做找出來的匹配是最大權完美匹配<br/>
						我們想要的是最大權匹配
						
						沒關係，把圖補成完全二分圖就行了<br/>
						雖然有辦法直接做最大權匹配(等下會說)<br/>
						但是這樣code會比較好寫
					</script>
				</section>
				<section>
					<h2>如果要做最大權二分匹配</h2>
					<div class="theorem">
						<p>
							vertex labeling 額外增加一個限制：<br/>
							對於所有匹配點\(z_u > 0\)
						</p>
						一開始先設所有\(z_u=max(\{w(e): e \in E\})/2\)<br/>
						vertex labeling為 0 的點最後將成為未匹配點
					</div>
					<div class="fragment">實作也不會太難大家可以試試看</div>
				</section>
			</section>
			<section>
				<section>
					<h1>KM演算法</h1>
					Kuhn-Munkres algorithm
				</section>
				<section>
					<h3>這個算法可以求二分圖的最大權完美匹配</h3>
				</section>
				<section>
					<h1>code</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						int n;
						int g[MAXN][MAXN],lx[MAXN],ly[MAXN],slack_y[MAXN];
						//用鄰接矩陣存二分圖，把點分成X、Y兩個集合
						//lx[x],ly[y]為x,y的vertex labeling
						//slack_y[y]紀錄和y相鄰的最小「非等邊」值
						int match_y[MAXN];
						//match_y[y]=x表示y和x匹配
						bool vx[MAXN],vy[MAXN];
						//vx,vy是dfs的時候判斷有沒有走過用的
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						bool dfs(int x){
							if(vx[x])return 0;
							vx[x]=1;
							for(int y=0,d;y<n;++y){
								if(vy[y])continue;
								d=lx[x]+ly[y]-g[x][y];
								if(d==0){//等邊
									vy[y]=1;
									if(match_y[y]==-1||dfs(match_y[y])){
										match_y[y]=x;
										return 1;
									}
								}else if(slack_y[y]>d)slack_y[y]=d;
								//非等邊，計算slack值
							}
							return 0;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接下來是主程式
						``` cpp
						inline int km(){
							memset(ly,0,sizeof(int)*n);
							memset(match_y,-1,sizeof(int)*n);
							for(int x=0;x<n;++x){
								lx[x]=-INF;
								for(int y=0;y<n;++y){
									lx[x]=max(lx[x],g[x][y]);
								}
							}
							for(int x=0;x<n;++x){
								for(int y=0;y<n;++y)slack_y[y]=INF;
								for(;;){
									memset(vx,0,sizeof(bool)*n);
									memset(vy,0,sizeof(bool)*n);
									if(dfs(x))break;//找到增廣路所以離開
									int d=INF;
									for(int y=0;y<n;++y){
										if(!vy[y])d=min(d,slack_y[y]);
									}
									//修改vertex labeling產生新的等邊
									for(int j=0;j<n;++j){
										if(vx[j])lx[j]-=d;
										if(vy[j])ly[j]+=d;
										else slack_y[j]-=d;
									}
								}
							}
							int ans=0;
							for(int y=0;y<n;++y)
								if(g[match_y[y]][y]!=-INF)
									ans+=g[match_y[y]][y];
							return ans;
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度分析</h2>
					<div class="theorem">
						<div class="label">複雜度</div>
						KM演算法<hr/>
						<p>dfs花\(\ord{|V|^2}\)的時間</p>
						<p>
							因為交錯樹最多有\(|V|-1\)條邊<br/>
							故主程式裡的無限迴圈最多執行\(\ord{|V|}\)次<br/>
						</p>
						<p>總共有\(|V|\)個點需要被增廣</p>
						總複雜度為:<br/>
						\(\ord{|V|*|V|*|V|^2}=\ord{|V|^4}\)
					</div>
				</section>
				<section>
					<h2>還可以更好</h2>
					<div class="theorem">
						<div class="label">複雜度</div>
						KM演算法<hr/>
						其實這算法複雜度可以到\(\ord{|V|^3}\)<br/>
						\(\implies\)每次增加新的等邊後不需要重新DFS<br/>
						<div class="fragment">怎麼實作具體就留給你們吧</div>
					</div>
				</section>
			</section>
			<section>
				<section>
					<h1>一般圖最大權匹配</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						# 預備知識
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 花
						一般圖跟二分圖最大的差別就是奇環<br/>
						之前的blossom算法是遇到奇環就把他縮成一個花<br/>
						
						這也可以變成線性規劃和他的對偶問題<br/>
						但是要對花做一些處理
					</script>
				</section>
				<section>
					<h2>定義</h2>
					<div class="theorem">
						<div class="label">定義</div>
						<hr/>
						設\(S⊆V\)<br/>
						\( \gamma(S)= \{(u,v) \in E \; : \; u \in S, \; v \in S\} \)<br/>
						\( O = \{ B⊆V \; : \; |B|是奇數且|B|≥3 \} \)
					</div>
				</section>
				<section>
					<h2>一般圖最大權完美匹配的線性規劃</h2>
					<div class="prob">
						<div class="label">原始問題</div>
						PRIMAL<hr/>
						<p>\( max \; \sum_{e∈E} \; w(e)x_e \)</p>
						限制:<br/>
						\( x(δ(u)) = 1 \; : \forall u∈V \)<br/>
						\(x(\gamma(B))≤\floor{\frac{|B|}{2}} \; : \forall B \in O\)<br/>
						\(x_e ≥ 0 \; : \forall e∈E \)
					</div>
				</section>
				<section>
					<h2>一般圖最大權完美匹配的對偶問題</h2>
					<div class="prob">
						<div class="label">對偶問題</div>
						DUAL<hr/>
						<p>\( min \; \sum_{u \in V} \; z_u +  \sum_{B \in O} \; \floor{\frac{|B|}{2}} z_B \)</p>
						<p>
							限制:<br/>
							\(z_B ≥ 0 \; : \forall B∈O \)<br/>
							\(z_e ≥ 0 \; : \forall e∈E \)
						</p>
						設 \(e=(u,v)\)，這裡$$z_e = z_u + z_v - w(e)+\sum_{\begin{subarray}{l} B \in O \\ u,v \in \gamma(B) \end{subarray}} z_B $$<br/>
					</div>
				</section>
				<section>
					<p>
						和二分圖一樣<br/>
						我們必須滿足\(x_e \in \{0,1\} \; : \forall e∈E \)<br/>
						因此必須在最大權完美匹配的時候<br/>
						讓所有匹配邊都是等邊
					</p>
					這裡等邊的定義為\(z_e=0\)的邊<br/>
					和二分圖不同的是，多了\(z_B\)要處理
				</section>
				<section>
					<h2>\(z_B\)什麼時候會大於0?</h2>
					從方程式可以看出<br/>
					盡量讓\(z_B=0\)是最好的做法<br/>
					但在不得已的時候還是要讓\(z_B>0\)<br/>
				</section>
				<section>
					<h2>\(z_B\)什麼時候會大於0?</h2>
					<p>
						在\(x(\gamma(B))=\floor{\frac{|B|}{2}}\)且\(x(δ(B)) = 1\)時<br/>
						讓\(z_B>0\)就可以了
					</p>
					因為除了在這種情況下<br/>
					\(z_B>0\)是沒有意義的
				</section>
				<section>
					<h2>所以可以有以下的對應關係</h2>
					<div class="theorem">
						\(x_e>0 \; \longrightarrow \; z_e=0 \qquad \forall e \in E\)<br/>
						\(z_B>0 \; \longrightarrow \; x(\gamma(B))=\floor{\frac{|B|}{2}}, \; x(δ(B)) = 1 \qquad \forall B \in O\)
					</div>
					<div class="fragment">
						可以發現在\(z_B>0\)時，\(B\)就會是一朵花
					</div>
				</section>
				<section>
					<p>
						以「等邊」的概念，結合之前的帶花樹算法:
					</p>
					<p>
						用「等邊」構成的增廣路不斷進行擴充<br/>
						由於用來擴充的邊全是「等邊」<br/>
						最後得到的最大權完美匹配當然全是「等邊」
					</p>
					<div class="fragment">還要處理花的問題</div>
				</section>
				<section>
					<h2>花</h2>
					<p>
						遇到花的時候，要把它縮成一個偶點<br/>
						把花中所有點都設為偶點，並讓他的\(z_B=0\)
					</p>
					由於縮花後會把花保存起來<br/>
					直到滿足某些條件才會拆開<br/>
					所以不能用之前的方法紀錄花
				</section>
				<section>
					<h2>花</h2>
					如果沒有特別說明<br/>
					我們之後提到的「點」<br/>
					都有包含縮花後產生的點
				</section>
				<section>
					<h2>花</h2>
					<p>
						因為花也有可能縮成點被加入queue中<br/>
						且花的數量是不固定的
					</p>
					<p>
						因此我們不能像之前一樣枚舉每個點看看有沒有增廣路<br/>
						所以在BFS的時候必須要把所有未匹配點都丟到queue中
					</p>
					<div class="fragment">
						這樣會同時產生很多棵交錯樹
					</div>
				</section>
			</section>
			<section>
				<section>
					<h2>總而言之</h2>
					<h2>這個算法可以分成四個部分</h2>
					<h3>
						<span class = "fragment">GROW</span>
						<span class = "fragment">、AUGMENT</span>
						<span class = "fragment">、SHRINK</span>
						<span class = "fragment">、EXPAND</span>
					</h3>
				</section>
				<section>
					<img src="img/Basic_notions.JPG">
				</section>
				<section data-markdown>
					<script type="text/template">
						GROW就是用「等邊」構成交錯樹<br/>
						AUGMENT就是找出增廣路並擴充<br/>
						SHRINK就是把花縮成一個點<br/>
						EXPAND就是把花拆開
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						注意在AUGMENT階段時<br/>
						因為所有未匹配點都會在不同的交錯樹上<br/>
						所以當增廣時兩棵交錯樹的偶點連在一起<br/>
						表示找到了一條擴充路徑
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 找不到等邊
						和二分圖一樣，也會有找不到「等邊」擴充的問題<br/>
						必須要調整vertex labeling
					</script>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					vertex labeling 仍要維持大於等於的性質<br/>
					而且既有的「等邊」不能被改變<br/>
					還要讓\(z_B\)盡量的小
				</section>
				<section>
					<div class="theorem">
						<div class="label">定義符號</div>
						奇偶點<hr/>
						<p>
							以\(u^-\)來表示\(u\)在交錯樹上為奇點<br/>
							以\(u^+\)來表示\(u\)在交錯樹上為偶點<br/>
							以\(u^{\varnothing}\)來表示\(u\)不再任何一棵交錯樹上<br/>
						</p>
						之後所有提到的\(B\)預設都是花<br/>
						並同時代表縮花之後的點<br/>
						花也可以有奇花偶花之分<br/>
						因此也適用\(B^+\)、\(B^-\)、\(B^{\varnothing}\)等符號
					</div>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr/>
						<p>
							設目前有\(r\)棵交錯樹 \( T_i = (U_{t_i},V_{t_i}) \; : 1≤i≤r\)<br/>
							令<br/>
							\( d1 = min(\{z_e: e=(u^+,v^{\varnothing})\})\)<br/>
							<p/>
							\( d2 = min(\{z_e: e=(u^+,v^+), \; u^+ \in T_i,\;v^+ \in T_j,\; i≠j\})/2\)<br/>
							<p/>
							\( d3 = min(\{z_{B^-}: B^- \in O\})/2\)
						</p>
						<p>
							注意這裡\(B\)是縮花之後的點，所以可以有奇偶性
						</p>
						設\(d=min(d1,d2,d3)\)<br/>
					</div>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr/>
						<p>
							讓<br/>
							\( \quad z_{u^+}\) -= \(d\)<br/>
							\( \quad z_{v^-}\) += \(d\)<br/>
							\( \quad z_{B^+}\) += \(2d\)<br/>
							\( \quad z_{B^-}\) -= \(2d\)
						</p>
						如果出現\(z_B = 0\;(d = d3)\)<br/>
						為了防止\(z_B < 0\)的情況<br/>
						所以要把這朵花拆了(EXPAND)<br/>
						拆花後只留下花裡的交替路徑<br/>
						並把花裡不在交替路徑上的點設為未走訪\((\varnothing)\)
					</div>
				</section>
				<section>
					<h2>expand</h2>
					<img src="img/expand.JPG">
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr/>
						如此便製造了一條(以上)的等邊，既有等邊保持不動<br/>
						並維持了\(z_e ≥ 0 \; : \forall e∈E \)的性質<br/>
						且最低限度增加了\(z_B\)<br/>
						可以繼續找增廣路了!
					</div>
				</section>
			</section>
			<section>
				<section>
					<h2>最大權匹配</h2>
					剛才的作法找出來的是 <b>最大權完美匹配</b> 啊<br/>
					我們要求的是 <b>最大權匹配</b>
				</section>
				<section>
					<h2>如果要做最大權匹配</h2>
					<div class="theorem">
						<p>
							vertex labeling 額外增加一個限制：<br/>
							對於所有匹配點\(u\)，\(z_u > 0\)
						</p>
						一開始先設所有\(z_u = max(\{w(e) : e \in E\})/2\)<br/>
						vertex labeling為 0 的點最後將成為未匹配點
					</div>
					<div class="fragment">這裡使用這種方式實做</div>
				</section>
			</section>
			<section>
				<section>
					<h1>一般圖最大權匹配</h1>
					<h1>code</h1>
					<h4>Edmonds' Maximum Weight Matching Algorithm</h4>
				</section>
				<section>
					這裡為了方便實作所以用邊權乘二來計算\(z_e\)的值<br/>
					這樣就不會出現浮點數誤差了
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						#define INF INT_MAX
						#define MAXN 400
						struct edge{
							int u,v,w;
							//表示(u,v)為一條邊其權重為w 
							edge(){}
							edge(int u,int v,int w):u(u),v(v),w(w){}
						}; 
						int n,n_x;
						//有n個點，編號為 1 ~ n
						//n_x表示當前點+花的數量，編號 n+1 ~ n_x 為花 
						edge g[ MAXN*2+1 ][ MAXN*2+1 ];
						//用鄰接矩陣存圖，因為最多有n-1朵花，所以大小會是MAXN*2
						vector<int> flower[ MAXN*2+1 ];
						//flower[b]記錄了b中有哪些點 
						//我們紀錄花中有那些點的方式是只紀錄花裡面的最外層花 
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/example_for_blossom_save.png)<br/>
						``` cpp
						flower[ b2 ] = { b1, 4, 3, 2, 11, 10, 9}
						flower[ b1 ] = { 6, 5, 8}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/example_for_blossom_save2.png)<br/>
						``` cpp
						flower[ b2 ] = { 9, b1, 4, 3, 2, 11, 10}
						flower[ b1 ] = { 5, 8, 6}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						int lab[ MAXN*2+1 ];
						//lab[u]用來紀錄zu, lab[b]用來記錄zB 
						int match[ MAXN*2+1 ],slack[ MAXN*2+1 ],st[ MAXN*2+1 ],pa[ MAXN*2+1 ];
						//match[x]=y表示(x,y)是匹配邊，這裡x、y可能是花 
						//slack[x]=u表示z(x,u)是所有和x相鄰的邊中最小的那條邊 
						//st[x]=b表示x所在的花為b，若x=b且b<=n表示正常節點 
						//pa[v]=u表示在交錯樹中，v的父母節點是u 
						int flower_from[ MAXN*2+1 ][ MAXN+1 ],S[ MAXN*2+1 ],vis[ MAXN*2+1 ];
						/*
						flower_from[b][x]=xs表示
						x是b裡面的一個點，xs是b裡面的一朵花或一個點，同時x=xs 或 x是xs的其中一個點 
						*/
						//S[u]={-1:沒走過 0:偶點 1:奇點}
						//vis只用在找lca的時候檢查是不是走過了
						queue<int> q;
						//BFS找增廣錄用的queue 
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/example_for_blossom_save.png)<br/>
						``` cpp
						flower_from[ b2 ][ 6 ] = b1
						flower_from[ b2 ][ 5 ] = b1
						flower_from[ b2 ][ 9 ] = 9
						flower_from[ b1 ][ 6 ] = 6
						以此類推
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline int e_delta(const edge &e){
							//計算ze，為了方便起見先把所有邊的權重乘二 
							//在花裡面計算e_delta值是錯誤的 
							return lab[e.u]+lab[e.v]-g[e.u][e.v].w*2;
						}
						inline void update_slack(int u,int x){
							//以u更新slack[x]的值 
							if(!slack[x]||e_delta(g[u][x])<e_delta(g[slack[x]][x])){
								slack[x]=u;
							}
						}
						inline void set_slack(int x){
							//算出slack[x]的值，slack[x]=0表示x是交錯樹中的節點 
							slack[x]=0;
							for(int u=1;u<=n;++u){
								if(g[u][x].w>0&&st[u]!=x&&S[st[u]]==0){
									update_slack(u,x);
								}
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						void q_push(int x){
							//把x丟到queue裡面，我們設定queue不能直接push一朵花
							if(x<=n)q.push(x);
							else{
								//若要push花必須要把花裡面原圖的點丟到queue裡面 
								for(size_t i=0;i<flower[x].size();i++){
									q_push(flower[x][i]);
								}
							}
						}
						inline void set_st(int x,int b){
							//將x所在的花設為b
							st[x]=b;
							if(x>n){
								//若x也是花的話，就必須要把x裡面的點其所在的花也設為b 
								for(size_t i=0;i<flower[x].size();++i){
									set_st(flower[x][i],b);
								}
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline int get_pr(int b,int xr){
							//xr是flower[b]中的一個點，回傳值pr是它的位置 
							//為了方便程式運作，我們讓 flower[b][0]~flower[b][pr]為花裡的交替路 
							int pr=find(flower[b].begin(),flower[b].end(),xr)-flower[b].begin(); 
							if(pr%2==1){
								//檢查他在花裡的位置，如果 flower[b][0]~flower[b][pr]不是交替路
								//就把整朵花反轉，重新計算pr 
								//讓 flower[b][0]~flower[b][pr]為花裡的交替路 
								reverse(flower[b].begin()+1,flower[b].end());
								return (int)flower[b].size()-pr;
							}else return pr;
						}
						```
					</script>
				</section>
				<section>
					<table>
					<tr>
						<td>
							<img src="img/example_for_blossom_save2.png">
						</td>
						<td style="vertical-align: top;">
							<div class="theorem">
							如果你使用<code>get_pr(b2,11)</code><br/>
							<code>flower[b2]</code>會變成<code>{9,10,11,2,3,4,b1}</code><br/>
							並回傳2
							<hr/>
							如果你使用<code>get_pr(b2,2)</code><br/>
							<code>flower[b2]</code>會變成<code>{9,b1,4,3,2,11,10}</code><br/>
							並回傳4
							</div>
						</td>
					</tr>
					</table>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline void set_match(int u,int v){
							//設定u和v為匹配邊，u和v有可能是花 
							match[u]=g[u][v].v;
							if(u>n){
								//如果u是花的話 
								edge e=g[u][v];
								int xr=flower_from[u][e.u];//找出e.u在flower[u]裡的哪朵花上 
								int pr=get_pr(u,xr);//找出xr的位置並讓0~pr為花裡的交替路徑 
								for(int i=0;i<pr;++i){//把花裡的交替路上的匹配邊和非匹配邊反轉 
									set_match(flower[u][i],flower[u][i^1]);
								}
								set_match(xr,v);//設定(xr,v)為匹配邊 
								rotate(flower[u].begin(),flower[u].begin()+pr,flower[u].end());
								//最後把pr設為花托，因為花的存法是flower[u][0]會是u的花托
								//所以要把flower[u][pr] rotate 到最前面 
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline void augment(int u,int v){
							//把u和u的祖先全部增廣，並設(u,v)為匹配邊 
							for(;;){
								int xnv=st[match[u]];
								set_match(u,v);
								if(!xnv)return;
								set_match(xnv,st[pa[xnv]]);
								u=st[pa[xnv]];
								v=xnv;
							}
						}
						inline int get_lca(int u,int v){
							//找出u,v在交錯樹上的lca 
							static int t=0;
							for(++t;u||v;swap(u,v)){
								if(u==0)continue;
								if(vis[u]==t)return u;
								vis[u]=t;//這種方法可以不用清空vis陣列 
								u=st[match[u]];
								if(u)u=st[pa[u]];
							}
							return 0;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline void add_blossom(int u,int lca,int v){
							//將u,v,lca這朵花縮成一個點 b
							//交錯樹上u,v的lca即為花托 
							int b=n+1;
							while(b<=n_x&&st[b])++b;
							if(b>n_x)++n_x;
							//找出目前未使用的花的編號 
							lab[b]=0;//設定zB=0 
							S[b]=0;//整朵花為一個偶點 
							match[b]=match[lca];//設定花的匹配邊為花托的匹配邊 
							flower[b].clear();
							flower[b].push_back(lca);
							for(int x=u,y;x!=lca;x=st[pa[y]]){
								flower[b].push_back(x);
								y=st[match[x]];
								flower[b].push_back(y);
								q_push(y);
							}
							reverse(flower[b].begin()+1,flower[b].end());
							for(int x=v,y;x!=lca;x=st[pa[y]]){
								flower[b].push_back(x);
								y=st[match[x]];
								flower[b].push_back(y);
								q_push(y);
							}
							//b中所有點以環形的方式加入flower[b]，並設花托為首個元素 
							set_st(b,b);//把整朵花裡所有的元素其所在的花設為b 
							for(int x=1;x<=n_x;++x){
								g[b][x].w=0;
								g[x][b].w=0;
							}
							for(int x=1;x<=n;++x){
								flower_from[b][x]=0;
							}
							for(size_t i=0;i<flower[b].size();++i){
								int xs=flower[b][i];
								for(int x=1;x<=n_x;++x){
									//設定b和x相鄰的邊為b裡面和x相鄰的邊e_delta最小的那條 
									if(g[b][x].w==0||e_delta(g[xs][x])<e_delta(g[b][x])){ 
										g[b][x]=g[xs][x];
										g[x][b]=g[x][xs];
									}
								}
								for(int x=1;x<=n;++x){
									if(flower_from[xs][x]){
										//如果b裡面的點xs有包含x
										//那flower_from[b][x]就會是xs 
										flower_from[b][x]=xs;
									}
								}
							}
							set_slack(b);
							//最後必須要設定b的slack值 
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline void expand_blossom(int b){
							//b是奇花且zB=0時，必須要把b拆開 
							//因為只拆開b而已，所以如果b裡面有包含其他的花  
							//不需要把他們拆開 
							for(size_t i=0;i<flower[b].size();++i){
								set_st(flower[b][i],flower[b][i]);
								//先把flower[b]裡每個元素所在的花設為自己 
							}
							int xr=flower_from[b][g[b][pa[b]].u];
							//xr表示交錯路上b的父母節點在flower[b]裡的哪朵花上
							int pr=get_pr(b,xr);//找出xr的位置並讓0~pr為花裡的交替路徑 
							for(int i=0;i<pr;i+=2){
								//把交替路徑拆開到交錯樹中
								//並把交替路中的偶點丟到queue裡 
								int xs=flower[b][i];
								int xns=flower[b][i+1];
								pa[xs]=g[xns][xs].u;
								S[xs]=1;
								S[xns]=0;
								slack[xs]=0;
								set_slack(xns);
								q_push(xns);
							}
							S[xr]=1;//這時xr會是奇點或奇花 
							pa[xr]=pa[b];
							for(size_t i=pr+1;i<flower[b].size();++i){
								//把花中所有不再交替路徑上的點設為未走訪 
								int xs=flower[b][i];
								S[xs]=-1;
								set_slack(xs);
							}
							st[b]=0;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool on_found_edge(const edge &e){
							//BFS時找到一條等邊e
							//要對她進行以下的處理 
							//這裡u一定是偶點 
							int u=st[e.u],v=st[e.v];
							if(S[v]==-1){
								//v是未走訪節點 
								pa[v]=e.u;
								S[v]=1;
								int nu=st[match[v]];
								slack[v]=0;
								slack[nu]=0;
								S[nu]=0;
								q_push(nu);
							}else if(S[v]==0){
								//v是偶點 
								int lca=get_lca(u,v);
								if(!lca){//lca=0表示u,v在不同的交錯樹上，有增廣路 
									augment(u,v);
									augment(v,u);
									return true;//找到增廣路 
								}else add_blossom(u,lca,v);
								//否則u,v在同棵樹上就會是一朵花，要縮花 
							}
							return false;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool matching(){
							memset(S+1,-1,sizeof(int)*n_x);
							memset(slack+1,0,sizeof(int)*n_x);
							q=queue<int>();//把queue清空 
							for(int x=1;x<=n_x;++x){
								if(st[x]==x&&!match[x]){
									//把所有非匹配點加入queue裡面，並設為偶點 
									pa[x]=0;
									S[x]=0;
									q_push(x);
								}
							}
							if(q.empty())return false;//所有點都有匹配了 
							for(;;){
								while(q.size()){
									//BFS 
									int u=q.front();
									q.pop();
									if(S[st[u]]==1)continue;
									for(int v=1;v<=n;++v){
										if(g[u][v].w>0&&st[u]!=st[v]){
											if(e_delta(g[u][v])==0){
											if(on_found_edge(g[u][v]))return true;
											}else update_slack(u,st[v]);
										}
									}
								}
								//修改lab值 
								int d=INF;
								for(int u=1;u<=n;++u){
									//這是為了防止出現lab<0的情況發生
									//只要有任何一個lab[u]=0就結束程式 
									if(S[st[u]]==0)
										d=min(d,lab[u]);
								} 
								for(int b=n+1;b<=n_x;++b){
									if(st[b]==b&&S[b]==1)
										d=min(d,lab[b]/2);
								}
								for(int x=1;x<=n_x;++x)
									if(st[x]==x&&slack[x]){
										if(S[x]==-1)
											d=min(d,e_delta(g[slack[x]][x]));
										else if(S[x]==0)
											d=min(d,e_delta(g[slack[x]][x])/2);
									}
								for(int u=1;u<=n;++u){
									if(S[st[u]]==0){
										if(lab[u]==d)return 0;
										//如果lab[u]=0就直接結束程式 
										lab[u]-=d;
									}else if(S[st[u]]==1)
										lab[u]+=d;
								}
								for(int b=n+1;b<=n_x;++b){
									if(st[b]==b){
										if(S[st[b]]==0)
											lab[b]+=d*2;
										else if(S[st[b]]==1)
											lab[b]-=d*2;
									}
								}
								q=queue<int>();//把queue清空 
								for(int x=1;x<=n_x;++x){
									//檢查看看有沒有增廣路徑產生 
									if(st[x]==x&&slack[x]&&st[slack[x]]!=x&&e_delta(g[slack[x]][x])==0)
										if(on_found_edge(g[slack[x]][x]))
											return true;
								}
								for(int b=n+1;b<=n_x;++b){
									//EXPAND的操作，把所有lab[b]=0的奇花拆開 
									if(st[b]==b&&S[b]==1&&lab[b]==0)
										expand_blossom(b);
								}
							}
							return false;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 主程式
						``` cpp
						inline pair<long long,int> weight_blossom(){
							//主程式，一開始先初始化 
							memset(match+1,0,sizeof(int)*n);
							n_x=n;//一開始沒有花 
							int n_matches=0;
							long long tot_weight=0;
							for(int u=0;u<=n;++u){
								//先把自己所在的花設為自己 
								st[u]=u;
								flower[u].clear();
							}
							int w_max=0;
							for(int u=1;u<=n;++u)
								for(int v=1;v<=n;++v){
									//u是一個點時，裡面所包含的點只有自己 
									flower_from[u][v]=(u==v?u:0);
									w_max=max(w_max,g[u][v].w);
									//找出最大的邊權 
								}
							for(int u=1;u<=n;++u)lab[u]=w_max;
							//讓所有的lab=最大的邊權  
							//因為這裡實作是用邊權乘二來計算ze的值所以不用除以二 
							while(matching())++n_matches;
							for(int u=1;u<=n;++u)
								if(match[u]&&match[u]<u)
									tot_weight+=g[u][match[u]].w;
							return make_pair(tot_weight,n_matches);
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 很重要 使用前一定要初始化
						``` cpp
						inline void init_weight_graph(){
							//在把邊輸入到圖裡面前必須要初始化 
							//因為是最大權匹配所以把不存在的邊設為0 
							for(int u=1;u<=n;++u)
								for(int v=1;v<=n;++v)
									g[u][v]=edge(u,v,0);
						}
						```
					</script>
				</section>
			</section>
			<section>
				<section>
					<h2>複雜度分析</h2>
					<div class="theorem">
						每朵花在一次BFS中只會被縮花或是拆花一次<br/>
						每次縮花拆花要\(\ord{\abs{V}}\)的時間<br/>
						最多總共有\(\ord{\abs{V}}\)朵花，故花的處理花費\(\ord{\abs{V}^2}\)<br/>
						而BFS花費\(\ord{\abs{V}+\abs{E}}\)<br/>
						因此找增廣路花費\(\ord{\abs{V}+\abs{E}}+\ord{\abs{V}^2}=\ord{\abs{V}^2}\)
					</div>
				</section>
				<section>
					<h2>複雜度分析</h2>
					<div class="theorem">
						最多做\(\abs{V}\)次BFS<br/>
						故總時間複雜度為\(\ord{\abs{V}^3}\)
					</div>
				</section>
			</section>
			<section>
				<div class="theorem">
					<div class="label">參考資料</div>
					<hr/>
					維基百科<p/>
					演算法筆記<p/>
					vfleaking的博客<p/>
					Blossom V: A new implementation of a minimum cost perfect matching algorithm<p/>
					Implementation of \(\ord{n m \; log \; n}\) Weighted Mathings in General Graphs: The Power of Data Strutures
				</div>
			</section>
		</div>
		<!--結束了-->
	</div>
	<script src="js/jquery.js"></script>
	<script src="reveal/lib/js/head.min.js"></script>
	<script src="reveal/js/reveal.js"></script>
	<script src="js/sketch.min.js"></script>
	<script>// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
	  controls: true,
	  progress: true,
	  history: true,
	  center: true,
	  //-showNotes: true,

	  transition: 'slide', // none/fade/slide/convex/concave/zoom

	  // Optional reveal.js plugins
	  dependencies: [
		{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
		{ src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
		{ src: 'reveal/plugin/zoom-js/zoom.js', async: true },
		{ src: 'reveal/plugin/notes/notes.js', async: true },
		{ src: 'reveal/plugin/math/math.js', async: true, callback: function() {
		  setTimeout( function() {
			MathJax.Hub.Config({
			  SVG: {
				scale: 90
				},
			  "HTML-CSS": {
				scale: 90,
				}
			  });
			}, 2000);
		  },
		  config: 'TeX-AMS_HTML-full'
		},
		{ src: 'js/dazzleSketch.js', async: true }
	  ]
	});</script>
	</body>
</html>